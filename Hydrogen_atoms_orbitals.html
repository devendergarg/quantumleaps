<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hydrogen Atom Orbitals with 2D Cross-Sections</title>

    <style>
        html, body { height: 100%; margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #111; color: #eee; overflow: hidden; display: flex; flex-direction: column; }
        #canvas-container { flex-grow: 1; position: relative; }
        #canvas-container canvas { display: block; }
        #cross-section-container { flex-shrink: 0; display: flex; justify-content: space-around; align-items: center; background-color: #222; padding: 10px 0; border-top: 2px solid #555; }
        .cross-section-view { text-align: center; }
        .cross-section-view h3 { margin: 0 0 5px 0; font-weight: normal; font-size: 0.9em; }
        .cross-section-view canvas { background-color: #000; border: 1px solid #444; }
        #info { position: absolute; top: 10px; left: 10px; padding: 10px; background-color: rgba(0, 0, 0, 0.5); border-radius: 5px; max-width: 350px; }
        h1 { margin: 0 0 10px 0; font-size: 1.2em; }
        p { margin: 5px 0; font-size: 0.9em; }
        #ui-container { position: absolute; top: 10px; right: 10px; padding: 15px; background-color: rgba(0, 0, 0, 0.7); border-radius: 5px; text-align: right; }
        #orbital-select { padding: 5px; font-size: 1em; }
        #orbital-info { margin-top: 10px; font-size: 0.9em; font-family: 'Courier New', Courier, monospace; }
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); padding: 20px; background: rgba(255, 255, 255, 0.8); color: #000; border-radius: 10px; font-size: 1.5em; z-index: 100; }
        #credits { position: absolute; bottom: 10px; right: 15px; color: #aaa; font-size: 12px; font-style: italic; pointer-events: none; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div id="canvas-container">
        <div id="info">
            <h1>Hydrogen Atom Electron Clouds</h1>
            <p>Visualizing the probability density |ψ|² for an electron in a hydrogen atom.</p>
            <p>Positive lobes of the wave function (ψ) are colored <span style="color:#ff8000;">orange</span>, negative lobes are <span style="color:#00bfff;">cyan</span>.</p>
        </div>
        <div id="ui-container">
            <label for="orbital-select">Select Orbital:</label>
            <select id="orbital-select">
                <option value="1s" selected>1s</option>
                <option value="2s">2s</option>
                <option value="2px">2p_x</option>
                <option value="2py">2p_y</option>
                <option value="2pz">2p_z</option>
                <option value="3s">3s</option>
                <option value="3px">3p_x</option>
                <option value="3py">3p_y</option>
                <option value="3pz">3p_z</option>
                <option value="3d_z2">3d_{z^2}</option>
                <option value="3d_xz">3d_{xz}</option>
                <option value="3d_yz">3d_{yz}</option>
                <option value="3d_xy">3d_{xy}</option>
                <option value="3d_x2-y2">3d_{x^2-y^2}</option>
            </select>
            <div id="orbital-info"></div>
        </div>
        <div id="loader" class="hidden">Generating...</div>
        <div id="credits">Created by Dr. Devender Garg</div>
    </div>
    
    <div id="cross-section-container">
        <div class="cross-section-view">
            <h3>XY Plane (at z=0)</h3>
            <canvas id="xy-canvas" width="300" height="300"></canvas>
        </div>
        <div class="cross-section-view">
            <h3>XZ Plane (at y=0)</h3>
            <canvas id="xz-canvas" width="300" height="300"></canvas>
        </div>
        <div class="cross-section-view">
            <h3>YZ Plane (at x=0)</h3>
            <canvas id="yz-canvas" width="300" height="300"></canvas>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const NUM_POINTS_3D = 75000;
        const NUM_POINTS_2D = 25000; // --- NEW: Dedicated number of points for 2D slices
        const AXIS_LENGTH = 25;
        let scene, camera, renderer, controls, points;
        
        const canvasContainer = document.getElementById('canvas-container');
        const canvas2D = {
            xy: document.getElementById('xy-canvas'),
            xz: document.getElementById('xz-canvas'),
            yz: document.getElementById('yz-canvas')
        };
        const ctx2D = {
            xy: canvas2D.xy.getContext('2d'),
            xz: canvas2D.xz.getContext('2d'),
            yz: canvas2D.yz.getContext('2d')
        };

        const loader = document.getElementById('loader');
        const orbitalSelect = document.getElementById('orbital-select');
        const orbitalInfoDiv = document.getElementById('orbital-info');

        const waveFunctions = { /* ... (wave functions are unchanged) ... */ '1s': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = Math.exp(-r); return { val: val, prob: val*val }; }, '2s': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (2 - r) * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '2px': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = x * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '2py': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = y * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '2pz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = z * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '3s': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (27 - 18 * r + 2 * r * r) * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3px': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (6 - r) * x * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3py': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (6 - r) * y * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3pz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (6 - r) * z * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_z2': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); if (r === 0) return { val: 0, prob: 0 }; const cosTheta = z / r; const val = (3 * cosTheta * cosTheta - 1) * r*r * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_xz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = x * z * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_yz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = y * z * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_xy': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = x * y * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_x2-y2': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (x * x - y * y) * Math.exp(-r / 3); return { val: val, prob: val*val }; } };
        const orbitalProperties = { /* ... (orbital properties are unchanged) ... */ '1s': { n: 1, l: 0, m: 0, maxProb: 1.0, boxSize: 15 }, '2s': { n: 2, l: 0, m: 0, maxProb: 4.0, boxSize: 25 }, '2px': { n: 2, l: 1, m: '±1',maxProb: 0.6, boxSize: 25 }, '2py': { n: 2, l: 1, m: '±1',maxProb: 0.6, boxSize: 25 }, '2pz': { n: 2, l: 1, m: 0, maxProb: 0.6, boxSize: 25 }, '3s': { n: 3, l: 0, m: 0, maxProb: 730.0, boxSize: 45 }, '3px': { n: 3, l: 1, m: '±1',maxProb: 15.0, boxSize: 45 }, '3py': { n: 3, l: 1, m: '±1',maxProb: 15.0, boxSize: 45 }, '3pz': { n: 3, l: 1, m: 0, maxProb: 15.0, boxSize: 45 }, '3d_z2': { n: 3, l: 2, m: 0, maxProb: 12.0, boxSize: 45 }, '3d_xz': { n: 3, l: 2, m: '±1',maxProb: 3.0, boxSize: 45 }, '3d_yz': { n: 3, l: 2, m: '±1',maxProb: 3.0, boxSize: 45 }, '3d_xy': { n: 3, l: 2, m: '±2',maxProb: 3.0, boxSize: 45 }, '3d_x2-y2':{ n: 3, l: 2, m: '±2',maxProb: 3.0, boxSize: 45 } };
        
        function init() { /* ... (init function is unchanged) ... */ scene = new THREE.Scene(); camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000); camera.position.z = 50; renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); renderer.setPixelRatio(window.devicePixelRatio); canvasContainer.appendChild(renderer.domElement); controls = new OrbitControls(camera, renderer.domElement); controls.enableDamping = true; const axesHelper = new THREE.AxesHelper(AXIS_LENGTH); scene.add(axesHelper); const labelX = createAxisLabel('X', new THREE.Vector3(AXIS_LENGTH + 2, 0, 0), '#FF4444'); const labelY = createAxisLabel('Y', new THREE.Vector3(0, AXIS_LENGTH + 2, 0), '#44FF44'); const labelZ = createAxisLabel('Z', new THREE.Vector3(0, 0, AXIS_LENGTH + 2), '#4444FF'); scene.add(labelX, labelY, labelZ); window.addEventListener('resize', onWindowResize, false); orbitalSelect.addEventListener('change', (event) => updateOrbital(event.target.value)); updateOrbital(orbitalSelect.value); animate(); }
        function createAxisLabel(text, position, color) { /* ... (function unchanged) ... */ const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const size = 64; canvas.width = size; canvas.height = size; context.font = `Bold 40px Arial`; context.fillStyle = color; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, size / 2, size / 2); const texture = new THREE.CanvasTexture(canvas); const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true }); const sprite = new THREE.Sprite(spriteMaterial); sprite.position.copy(position); sprite.scale.set(3, 3, 1.0); return sprite; }

        function generateOrbitalCloud3D(orbitalName) {
            const props = orbitalProperties[orbitalName]; const waveFunc = waveFunctions[orbitalName]; const maxProb = props.maxProb; const boxSize = props.boxSize;
            const positions = []; const colors = []; const colorPositive = new THREE.Color(0xff8000); const colorNegative = new THREE.Color(0x00bfff);
            let pointsFound = 0; let attempts = 0; const maxAttempts = 20000000;
            while (pointsFound < NUM_POINTS_3D && attempts < maxAttempts) {
                const x = (Math.random() - 0.5) * boxSize; const y = (Math.random() - 0.5) * boxSize; const z = (Math.random() - 0.5) * boxSize;
                const { val, prob } = waveFunc(x, y, z);
                if (Math.random() < prob / maxProb) {
                    positions.push(x, y, z);
                    const color = (val > 0) ? colorPositive : colorNegative;
                    colors.push(color.r, color.g, color.b);
                    pointsFound++;
                }
                attempts++;
            }
            if (attempts >= maxAttempts) console.warn(`3D Generation stopped for ${orbitalName}.`);
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7, depthWrite: false });
            return new THREE.Points(geometry, material);
        }

        // --- NEW: DEDICATED 2D DATA GENERATION FUNCTION ---
        function generate2DCrossSectionData(orbitalName, plane) {
            const props = orbitalProperties[orbitalName];
            const waveFunc = waveFunctions[orbitalName];
            const maxProb = props.maxProb;
            const boxSize = props.boxSize;
            
            const points2D = [];
            let pointsFound = 0;
            let attempts = 0;
            const maxAttempts = NUM_POINTS_2D * 1000; // Generous attempt limit

            while (pointsFound < NUM_POINTS_2D && attempts < maxAttempts) {
                const u = (Math.random() - 0.5) * boxSize;
                const v = (Math.random() - 0.5) * boxSize;
                
                let x=0, y=0, z=0;
                if (plane === 'xy') { x = u; y = v; z = 0; }
                else if (plane === 'xz') { x = u; z = v; y = 0; }
                else if (plane === 'yz') { y = u; z = v; x = 0; }

                const { val, prob } = waveFunc(x, y, z);
                
                if (Math.random() < prob / maxProb) {
                    points2D.push({u, v, val});
                    pointsFound++;
                }
                attempts++;
            }
            return points2D;
        }

        // --- NEW: GENERIC FUNCTION TO DRAW A 2D SLICE ---
        function drawSlice(ctx, data, boxSize) {
            const canvas = ctx.canvas;
            const w = canvas.width;
            const h = canvas.height;
            const particleSize = 1;

            ctx.clearRect(0, 0, w, h);
            const colorPositive = 'rgb(255, 128, 0)';
            const colorNegative = 'rgb(0, 191, 255)';

            for (const p of data) {
                const pixelX = (p.u / boxSize + 0.5) * w;
                const pixelY = (-p.v / boxSize + 0.5) * h; // Invert v-axis
                ctx.fillStyle = (p.val > 0) ? colorPositive : colorNegative;
                ctx.fillRect(pixelX, pixelY, particleSize, particleSize);
            }
        }

        // --- MODIFIED updateOrbital TO ORCHESTRATE EVERYTHING ---
        function updateOrbital(orbitalName) {
            loader.classList.remove('hidden');
            setTimeout(() => {
                // Clean up previous 3D object
                if (points) {
                    scene.remove(points);
                    points.geometry.dispose();
                    points.material.dispose();
                }
                
                // Generate 3D view
                points = generateOrbitalCloud3D(orbitalName);
                scene.add(points);

                // Generate and draw all 2D views
                const props = orbitalProperties[orbitalName];
                const dataXY = generate2DCrossSectionData(orbitalName, 'xy');
                const dataXZ = generate2DCrossSectionData(orbitalName, 'xz');
                const dataYZ = generate2DCrossSectionData(orbitalName, 'yz');
                
                drawSlice(ctx2D.xy, dataXY, props.boxSize);
                drawSlice(ctx2D.xz, dataXZ, props.boxSize);
                drawSlice(ctx2D.yz, dataYZ, props.boxSize);

                // Update info panel
                orbitalInfoDiv.innerHTML = `Quantum Numbers:<br>n = ${props.n}<br>l = ${props.l}<br>m = ${props.m}`;
                loader.classList.add('hidden');
            }, 50);
        }

        function onWindowResize() { /* ... (unchanged) ... */ camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); }
        function animate() { /* ... (unchanged) ... */ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

        init();
    </script>
</body>
</html>