<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js Electron Interference Experiment (V16)</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; background-color: #111; color: #ddd; }
        #container { width: 100vw; height: 100vh; }
        .ui-panel { position: absolute; padding: 15px; background: rgba(20, 20, 30, 0.85); border: 1px solid #445; border-radius: 8px; box-sizing: border-box; }
        #controls { top: 10px; left: 10px; width: 320px; transition: transform 0.3s ease-in-out; }
        #stats { top: 10px; right: 10px; text-align: right; }
        #toggleControlsBtn { display: none; }
        h2 { margin-top: 0; border-bottom: 1px solid #445; padding-bottom: 8px; font-weight: 400; font-size: 1.2em; }
        h2 small { font-size: 0.6em; color: #999; }
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-size: 0.9em; }
        input[type="range"] { width: 100%; cursor: pointer; }
        button { padding: 10px 15px; margin-right: 5px; border: none; background-color: #0d6efd; color: white; cursor: pointer; border-radius: 4px; transition: background-color 0.2s; font-size: 1em; }
        button:hover { background-color: #0b5ed7; }
        #toggleFiringBtn.active { background-color: #ffc107; color: #000; }
        #toggleFiringBtn.active:hover { background-color: #e0a800; }
        #resetBtn { background-color: #dc3545; }
        #resetBtn:hover { background-color: #c82333; }
        #electronCounter { font-size: 1.5em; font-weight: bold; color: #00ffaa; }
        @media (max-width: 768px) {
            #stats { right: auto; left: 10px; }
            #controls { width: calc(100% - 20px); left: 10px; top: auto; bottom: 10px; z-index: 20; max-height: 50vh; overflow-y: auto; }
            #controls.hidden { transform: translateY(calc(100% + 20px)); }
            #toggleControlsBtn { display: block; position: absolute; top: 10px; right: 10px; z-index: 10; }
            button { padding: 12px 16px; }
            label { font-size: 1em; }
            h2 { font-size: 1.3em; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="stats" class="ui-panel">
        <div>Electrons Detected</div>
        <div id="electronCounter">0</div>
    </div>
    <div id="controls" class="ui-panel">
        <h2>Experiment Controls <small>v16.0</small></h2>
        <div class="control-group">
            <button id="fireOneBtn">Fire One</button>
            <button id="toggleFiringBtn">Start Firing</button>
        </div>
        <div class="control-group">
            <label for="fireRate">Firing Rate: <span id="fireRateValue"></span> e‚Åª/sec</label>
            <input type="range" id="fireRate" min="1" max="500" value="25" step="1">
        </div>
        <hr style="border-color: #445;">
        <div class="control-group">
            <label for="slitSeparation">Slit Separation: <span id="slitSeparationValue"></span></label>
            <input type="range" id="slitSeparation" min="5" max="30" value="12" step="0.1">
        </div>
        <div class="control-group">
            <label for="slitWidth">Slit Width: <span id="slitWidthValue"></span></label>
            <input type="range" id="slitWidth" min="0.5" max="10" value="2.5" step="0.1">
        </div>
        <div class="control-group">
            <label for="wavelength">Wavelength: <span id="wavelengthValue"></span></label>
            <input type="range" id="wavelength" min="0.5" max="5" value="1.5" step="0.1">
        </div>
        <div class="control-group">
            <label for="screenDistance">Screen Distance: <span id="screenDistanceValue"></span></label>
            <input type="range" id="screenDistance" min="40" max="100" value="60" step="1">
        </div>
        <hr style="border-color: #445;">
        <div class="control-group">
            <button id="resetBtn">Reset Simulation</button>
        </div>
    </div>
    <button id="toggleControlsBtn">Show Controls</button>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const MAX_PARTICLES = 4000;
        const particlePool = [];
        let poolCursor = 0;

        let scene, camera, renderer, controls;
        let emitter, slitBarrier, screen;
        let screenCanvas, screenContext, screenTexture;
        const activeParticles = [];

        const EMITTER_RADIUS = 3;
        const EMITTER_HEIGHT = 80;
        
        const SCREEN_WIDTH = 120, SCREEN_HEIGHT = 80, CANVAS_RESOLUTION = 1024;
        let isFiringContinuously = false, hitCounter = 0, lastFireTime = 0, ghostPairId = 0;
        const params = { slitSeparation: 12, slitWidth: 2.5, wavelength: 1.5, screenDistance: 60, fireRate: 25 };
        
        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x101018);
            scene.fog = new THREE.Fog(0x101018, 150, 300);
            camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 90);
            const container = document.getElementById('container');
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.target.set(0, 10, 0);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const keyLight = new THREE.DirectionalLight(0xffffff, 1.0);
            keyLight.position.set(-60, 60, 60);
            scene.add(keyLight);
            initParticlePool();
            createEmitter();
            createSlitBarrier();
            createScreen();
            setupUI();
            window.addEventListener('resize', onWindowResize);
        }

        function initParticlePool() {
            const electronGeom = new THREE.SphereGeometry(0.5, 12, 12);
            const ghostGeom = new THREE.SphereGeometry(0.3, 8, 8);
            const electronMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00cc00, emissiveIntensity: 1, fog: false });
            const ghostMat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00cc00, emissiveIntensity: 1.5, transparent: true, opacity: 0.5, fog: false });
            for (let i = 0; i < MAX_PARTICLES; i++) {
                const isGhost = i % 3 !== 0;
                const particle = {
                    mesh: new THREE.Mesh(isGhost ? ghostGeom : electronGeom, isGhost ? ghostMat : electronMat),
                    isActive: false, isGhost: isGhost, velocity: new THREE.Vector3(),
                    pairId: -1, finalHitX: 0, finalHitY: 0
                };
                particle.mesh.visible = false;
                particlePool.push(particle);
                scene.add(particle.mesh);
            }
        }
        function getParticleFromPool(isGhost = false) {
            for (let i = 0; i < MAX_PARTICLES; i++) {
                poolCursor = (poolCursor + 1) % MAX_PARTICLES;
                const particle = particlePool[poolCursor];
                if (!particle.isActive && particle.isGhost === isGhost) {
                    particle.isActive = true;
                    particle.mesh.visible = true;
                    activeParticles.push(particle);
                    return particle;
                }
            }
            return null;
        }
        function returnParticleToPool(particle) { particle.isActive = false; particle.mesh.visible = false; }
        function setupUI() {
            const controlsPanel = document.getElementById('controls');
            const toggleControlsBtn = document.getElementById('toggleControlsBtn');
            if (window.innerWidth <= 768) { controlsPanel.classList.add('hidden'); }
            toggleControlsBtn.addEventListener('click', () => {
                const isHidden = controlsPanel.classList.toggle('hidden');
                toggleControlsBtn.textContent = isHidden ? 'Show Controls' : 'Hide Controls';
            });
            const uiMap = {
                'fireRate': { el: document.getElementById('fireRate'), param: 'fireRate' },
                'slitSeparation': { el: document.getElementById('slitSeparation'), param: 'slitSeparation', updateFn: updateSlitBarrier },
                'slitWidth': { el: document.getElementById('slitWidth'), param: 'slitWidth', updateFn: updateSlitBarrier },
                'wavelength': { el: document.getElementById('wavelength'), param: 'wavelength' },
                'screenDistance': { el: document.getElementById('screenDistance'), param: 'screenDistance', updateFn: () => { screen.position.z = -params.screenDistance; } },
            };
            const updateSliderValue = (id, value) => { document.getElementById(id + 'Value').textContent = parseFloat(value).toFixed(id === 'fireRate' ? 0 : 2); };
            for (const key in uiMap) {
                const item = uiMap[key];
                updateSliderValue(key, params[item.param]);
                item.el.addEventListener('input', e => {
                    params[item.param] = parseFloat(e.target.value);
                    if (key === 'slitWidth' && params.slitWidth > params.slitSeparation) { params.slitWidth = params.slitSeparation; item.el.value = params.slitWidth; }
                    if (key === 'slitSeparation' && params.slitSeparation < params.slitWidth) { params.slitSeparation = params.slitWidth; item.el.value = params.slitSeparation; }
                    updateSliderValue(key, params[item.param]);
                    if (item.updateFn) item.updateFn();
                });
            }
            document.getElementById('fireOneBtn').addEventListener('click', () => fireElectron());
            document.getElementById('toggleFiringBtn').addEventListener('click', () => {
                isFiringContinuously = !isFiringContinuously;
                if (isFiringContinuously) { lastFireTime = performance.now(); }
                const btn = document.getElementById('toggleFiringBtn');
                btn.textContent = isFiringContinuously ? 'Stop Firing' : 'Start Firing';
                btn.classList.toggle('active', isFiringContinuously);
            });
            document.getElementById('resetBtn').addEventListener('click', resetSimulation);
        }
        
        function createEmitter() {
            emitter = new THREE.Group();
            const shellGeom = new THREE.CylinderGeometry(EMITTER_RADIUS, EMITTER_RADIUS, EMITTER_HEIGHT, 32);
            const shellMat = new THREE.MeshStandardMaterial({
                color: 0x001100,
                emissive: 0x00ff00,
                emissiveIntensity: 2.5,
                fog: false
            });
            const shell = new THREE.Mesh(shellGeom, shellMat);
            emitter.add(shell);
            emitter.position.set(0, SCREEN_HEIGHT / 2, 50);
            scene.add(emitter);
        }

        function createSlitBarrier() {
            if (slitBarrier) scene.remove(slitBarrier);
            slitBarrier = new THREE.Group();
            const barrierMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                metalness: 0.9, 
                roughness: 0.2,
                fog: false
            });
            const barrierDepth = 4;
            const halfSep = params.slitSeparation / 2, halfWidth = params.slitWidth / 2;
            const leftSlit_R_edge = -halfSep + halfWidth, rightSlit_L_edge = halfSep - halfWidth;
            const centerWidth = rightSlit_L_edge - leftSlit_R_edge;
            if (centerWidth > 0.01) {
                const centerGeom = new THREE.BoxGeometry(centerWidth, SCREEN_HEIGHT, barrierDepth);
                const centerMesh = new THREE.Mesh(centerGeom, barrierMaterial);
                centerMesh.position.x = leftSlit_R_edge + centerWidth / 2;
                slitBarrier.add(centerMesh);
            }
            const leftWallWidth = (-halfSep - halfWidth) - (-SCREEN_WIDTH / 2);
            if (leftWallWidth > 0) {
                const leftGeom = new THREE.BoxGeometry(leftWallWidth, SCREEN_HEIGHT, barrierDepth);
                const leftMesh = new THREE.Mesh(leftGeom, barrierMaterial);
                leftMesh.position.x = (-SCREEN_WIDTH / 2) + leftWallWidth / 2;
                slitBarrier.add(leftMesh);
            }
            const rightWallWidth = (SCREEN_WIDTH / 2) - (halfSep + halfWidth);
            if (rightWallWidth > 0) {
                const rightGeom = new THREE.BoxGeometry(rightWallWidth, SCREEN_HEIGHT, barrierDepth);
                const rightMesh = new THREE.Mesh(rightGeom, barrierMaterial);
                rightMesh.position.x = (halfSep + halfWidth) + rightWallWidth / 2;
                slitBarrier.add(rightMesh);
            }
            slitBarrier.position.y = SCREEN_HEIGHT / 2;
            scene.add(slitBarrier);
        }
        function updateSlitBarrier() { createSlitBarrier(); }

        function createScreen() {
            screenCanvas = document.createElement('canvas');
            screenCanvas.width = CANVAS_RESOLUTION; screenCanvas.height = CANVAS_RESOLUTION;
            screenContext = screenCanvas.getContext('2d');
            screenContext.fillStyle = '#050508'; screenContext.fillRect(0, 0, CANVAS_RESOLUTION, CANVAS_RESOLUTION);
            screenTexture = new THREE.CanvasTexture(screenCanvas);
            const screenMaterial = new THREE.MeshBasicMaterial({ 
                map: screenTexture,
                fog: false
            });
            const screenGeometry = new THREE.BoxGeometry(SCREEN_WIDTH, SCREEN_HEIGHT, 1);
            screen = new THREE.Mesh(screenGeometry, screenMaterial);
            screen.position.z = -params.screenDistance;
            screen.position.y = SCREEN_HEIGHT / 2;
            scene.add(screen);
        }

        function fireElectron() {
            const electron = getParticleFromPool(false);
            if (!electron) return;

            const baseSpeed = 1.2;
            const dynamicSpeed = baseSpeed + (params.fireRate / 500) * baseSpeed;

            const emission_z = emitter.position.z - EMITTER_RADIUS;
            const horizontalSpread = EMITTER_RADIUS * 1.8; 

            const startPosition = new THREE.Vector3(
                (Math.random() - 0.5) * horizontalSpread,
                Math.random() * SCREEN_HEIGHT,
                emission_z
            );
            electron.mesh.position.copy(startPosition);

            const spreadFactor = 0.02;
            electron.velocity.set(
                (Math.random() - 0.5) * spreadFactor,
                (Math.random() - 0.5) * spreadFactor,
                -1
            ).normalize().multiplyScalar(dynamicSpeed);
        }

        // --- MODIFIED FUNCTION: createInterferenceVisuals ---
        function createInterferenceVisuals(electron) {
            const finalHitX = calculateHitXPosition();
            const finalHitY = (Math.random() - 0.5) * (SCREEN_HEIGHT * 0.9);
            const slitPositionsX = [-params.slitSeparation / 2, params.slitSeparation / 2];
            const endPosition = new THREE.Vector3(finalHitX, screen.position.y + finalHitY, screen.position.z);
            
            for (const posX of slitPositionsX) {
                const ghost = getParticleFromPool(true);
                if (!ghost) continue;
                ghost.pairId = ghostPairId;
                ghost.finalHitX = finalHitX;
                ghost.finalHitY = finalHitY;

                // --- START OF CHANGE ---
                // Calculate a random horizontal offset within the slit's width.
                const randomXOffset = (Math.random() - 0.5) * params.slitWidth;
                
                // Apply the offset to the slit's center position.
                const startPosition = new THREE.Vector3(
                    posX + randomXOffset, 
                    electron.mesh.position.y, 
                    0
                );
                // --- END OF CHANGE ---

                ghost.mesh.position.copy(startPosition);
                ghost.velocity.subVectors(endPosition, startPosition).normalize().multiplyScalar(Math.abs(electron.velocity.z));
            }
            ghostPairId++;
        }

        function resetSimulation() {
            activeParticles.forEach(p => returnParticleToPool(p));
            activeParticles.length = 0;
            screenContext.fillStyle = '#050508'; screenContext.fillRect(0, 0, CANVAS_RESOLUTION, CANVAS_RESOLUTION);
            screenTexture.needsUpdate = true;
            hitCounter = 0;
            document.getElementById('electronCounter').textContent = hitCounter;
            if (isFiringContinuously) document.getElementById('toggleFiringBtn').click();
        }
        function calculateHitXPosition() {
            const L = params.screenDistance, d = params.slitSeparation, lambda = params.wavelength, a = params.slitWidth, xRange = SCREEN_WIDTH * 0.95;
            while (true) {
                let x = (Math.random() - 0.5) * xRange;
                const interference = Math.cos(Math.PI * d * x / (lambda * L)) ** 2;
                const diffractionArg = Math.PI * a * x / (lambda * L);
                const diffraction = (diffractionArg === 0) ? 1 : (Math.sin(diffractionArg) / diffractionArg) ** 2;
                if (Math.random() < interference * diffraction) return x;
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate(time) {
            requestAnimationFrame(animate);

            if (isFiringContinuously) {
                const elapsed = time - lastFireTime;
                const interval = 1000 / params.fireRate;
                if (elapsed >= interval) {
                    const numToFire = Math.floor(elapsed / interval);
                    for (let i = 0; i < numToFire; i++) { fireElectron(); }
                    lastFireTime += numToFire * interval;
                }
            }
            let screenNeedsUpdate = false;
            for (let i = activeParticles.length - 1; i >= 0; i--) {
                const particle = activeParticles[i];
                particle.mesh.position.add(particle.velocity);
                if (!particle.isGhost && particle.mesh.position.z <= 0) {
                    createInterferenceVisuals(particle);
                    returnParticleToPool(particle);
                    activeParticles.splice(i, 1);
                } else if (particle.isGhost && particle.mesh.position.z <= screen.position.z) {
                    const canvasX = (CANVAS_RESOLUTION / 2) + (particle.finalHitX / SCREEN_WIDTH) * CANVAS_RESOLUTION;
                    const canvasY = (CANVAS_RESOLUTION / 2) - (particle.finalHitY / SCREEN_HEIGHT) * CANVAS_RESOLUTION;
                    screenContext.fillStyle = `rgba(150, 255, 255, 0.8)`;
                    screenContext.beginPath(); screenContext.arc(canvasX, canvasY, 1.5, 0, Math.PI * 2); screenContext.fill();
                    screenNeedsUpdate = true;
                    hitCounter++;
                    const currentPairId = particle.pairId;
                    for (let j = activeParticles.length - 1; j >= 0; j--) {
                        if (activeParticles[j].pairId === currentPairId) {
                            returnParticleToPool(activeParticles[j]);
                            activeParticles.splice(j, 1);
                        }
                    }
                }
            }
            if (screenNeedsUpdate) {
                screenTexture.needsUpdate = true;
                document.getElementById('electronCounter').textContent = hitCounter;
            }
            controls.update();
            renderer.render(scene, camera);
        }
    </script></body></html>