<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Quantum Harmonic Oscillator (Corrected)</title>
    <style>
        :root {
            --bg-color: #1a1a2e; --panel-color: #16213e; --text-color: #e0e0e0;
            --primary-color: #0f3460; --accent-color-1: #3498db; --accent-color-2: #2ecc71;
            --accent-color-3: #e74c3c; --highlight-color: #e94560;
        }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; display: flex; flex-direction: column; background-color: var(--bg-color); color: var(--text-color); margin: 0; padding: 1em; overflow-x: hidden; }
        header { text-align: center; margin-bottom: 1.5em; }
        header h1 { color: var(--highlight-color); margin-bottom: 0.2em; font-size: 2em; }
        header p { max-width: 600px; margin: 0 auto; }
        main { display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 1400px; margin: 0 auto; }
        @media (min-width: 950px) { main { flex-direction: row; align-items: flex-start; } aside.controls { position: sticky; top: 20px; } }
        .canvas-wrapper { 
            flex: 3; 
            min-width: 0; 
            background-color: #0c0c14; 
            border: 1px solid var(--primary-color); 
            border-radius: 8px; 
            box-shadow: 0 4px 15px rgba(0,0,0,0.4); 
            position: relative; 
            cursor: pointer;
        }
        canvas { display: block; width: 100%; height: auto; }
        #qhoCanvas, #numberCanvas { display: none; } /* Hide non-default canvases */
        .plot-labels { position: absolute; bottom: 10px; left: 10px; display: flex; flex-wrap: wrap; gap: 15px; font-size: 0.8em; pointer-events: none; }
        .plot-labels div::before { content: ''; display: inline-block; width: 12px; height: 12px; margin-right: 5px; vertical-align: middle; border-radius: 2px; }
        #label-prob { color: var(--accent-color-3); } #label-prob::before { background-color: var(--accent-color-3); }
        #label-re { color: var(--accent-color-1); } #label-re::before { background-color: var(--accent-color-1); }
        #label-im { color: var(--accent-color-2); } #label-im::before { background-color: var(--accent-color-2); }
        aside.controls { flex: 1; min-width: 300px; padding: 20px; background-color: var(--panel-color); border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.4); }
        .control-group { margin-bottom: 20px; }
        h2 { border-bottom: 1px solid var(--primary-color); padding-bottom: 10px; margin-top: 0; }
        label { display: block; margin-bottom: 8px; font-weight: 500; }
        .param-display { font-family: monospace; font-weight: bold; color: var(--highlight-color); }
        hr { border-color: var(--primary-color); margin: 25px 0; }
        .selector-group { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
        .selector-btn { flex: 1; padding: 10px; font-size: 0.9em; font-weight: 500; background-color: transparent; color: var(--text-color); border: 2px solid var(--primary-color); border-radius: 5px; cursor: pointer; transition: all 0.2s ease-in-out; min-width: 80px; }
        .selector-btn:hover { background-color: var(--primary-color); }
        .selector-btn.active { background-color: var(--highlight-color); border-color: var(--highlight-color); color: #fff; box-shadow: 0 0 10px rgba(233, 69, 96, 0.5); }
        .simulation-controls { display: flex; gap: 10px; margin-bottom: 20px; }
        .sim-button { flex: 1; padding: 12px; border: none; border-radius: 5px; background-color: var(--primary-color); color: var(--text-color); cursor: pointer; font-size: 1em; transition: all 0.2s; display: flex; justify-content: center; align-items: center; gap: 8px; }
        .sim-button:hover { background-color: #1a4a8a; }
        .sim-button:disabled { background-color: #0a2140; color: #aaa; cursor: not-allowed; }
        .sim-button:disabled:hover { background-color: #0a2140; }
        .sim-button svg { width: 18px; height: 18px; fill: currentColor; }
        #timeDisplay { margin-top: 10px; font-family: monospace; }
        input[type=range] { -webkit-appearance: none; background: transparent; width: 100%; }
        input[type=range]::-webkit-slider-runnable-track { height: 6px; background: #0f3460; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%; background: var(--highlight-color); margin-top: -6px; }
        .toggle-group { display: flex; justify-content: space-around; align-items: center; }
        .toggle-group label { display: flex; align-items: center; cursor: pointer; margin-bottom: 0; }
        .toggle-group label.disabled { opacity: 0.5; cursor: not-allowed; }
        .toggle-group input[type="checkbox"] { display: none; }
        .toggle-group .custom-checkbox { width: 20px; height: 20px; border: 2px solid var(--primary-color); border-radius: 4px; margin-right: 8px; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
        .toggle-group .custom-checkbox svg { width: 14px; height: 14px; fill: #fff; opacity: 0; transform: scale(0.5); transition: all 0.2s; }
        .toggle-group input[type="checkbox"]:checked + .custom-checkbox { border-color: var(--highlight-color); background-color: var(--highlight-color); }
        .toggle-group input[type="checkbox"]:checked + .custom-checkbox svg { opacity: 1; transform: scale(1); }
        #prob-label { color: var(--accent-color-3); } #re-label { color: var(--accent-color-1); } #im-label { color: var(--accent-color-2); }
        .explanation-wrapper { max-width: 1400px; margin: 10px auto; background-color: var(--panel-color); border-radius: 8px; }
        .explanation-toggle { padding: 15px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-weight: 500; }
        .explanation-toggle svg { width: 20px; height: 20px; transition: transform 0.3s ease; }
        .explanation-toggle.is-open svg { transform: rotate(180deg); }
        #descriptionContainer { max-height: 0; overflow: hidden; transition: max-height 0.4s ease-in-out; padding: 0 20px; }
        #descriptionContainer.is-visible { padding: 0 20px 20px 20px; }
        #descriptionContainer h4 { color: var(--highlight-color); margin-bottom: 0.5em; }
        #descriptionContainer p, #descriptionContainer li { font-size: 0.9em; line-height: 1.6; }
        #descriptionContainer strong { color: var(--text-color); }
        #descriptionContainer code { font-family: monospace; font-weight: bold; }
        
        footer {
            text-align: center;
            margin-top: 2em;
            padding-top: 1.5em;
            border-top: 1px solid var(--primary-color);
            font-size: 0.9em;
            color: #aaa;
        }
        footer strong {
            color: var(--text-color);
            font-weight: 500;
        }
    </style>
</head>
<body>

    <header> <h1>Interactive Quantum Harmonic Oscillator</h1> <p>Explore different quantum states and watch them evolve in time.</p> </header>
    <main>
        <div class="canvas-wrapper">
            <canvas id="qhoCanvas" width="800" height="800"></canvas>
            <canvas id="phaseCanvas" width="800" height="800"></canvas>
            <canvas id="numberCanvas" width="800" height="800"></canvas>
            <div class="plot-labels" style="display: none;"> <div id="label-prob">|Ψ|²</div> <div id="label-re">Re(Ψ)</div> <div id="label-im">Im(Ψ)</div> </div>
        </div>
        <aside class="controls">
            <h2>View Type</h2>
            <div class="control-group">
                <div class="selector-group">
                    <button class="selector-btn view-btn" data-view="position">Position</button>
                    <button class="selector-btn view-btn active" data-view="phase">Phase Space</button>
                    <button class="selector-btn view-btn" data-view="number">Number Space</button>
                </div>
            </div>
            <h2>State Parameters</h2>
            <div class="control-group"> <label>State Type:</label> <div class="selector-group"> <button class="selector-btn state-btn active" data-state="coherent">Coherent</button> <button class="selector-btn state-btn" data-state="squeezed">Squeezed</button> <button class="selector-btn state-btn" data-state="number">Number</button> <button class="selector-btn state-btn" data-state="thermal">Thermal</button> </div> </div>
            <div id="numberControls" class="control-group" style="display:none;"> <label for="nSlider">Quantum Number n = <span id="nValue" class="param-display">1</span></label> <input type="range" id="nSlider" min="0" max="15" value="1" step="1"> </div>
            <div id="coherentControls" class="control-group"> <label for="alphaReSlider">Re(α) = <span id="alphaReValue" class="param-display">2.0</span></label> <input type="range" id="alphaReSlider" min="-4" max="4" value="2" step="0.1"> <label for="alphaImSlider">Im(α) = <span id="alphaImValue" class="param-display">0.0</span></label> <input type="range" id="alphaImSlider" min="-4" max="4" value="0" step="0.1"> </div>
            <div id="squeezedControls" class="control-group" style="display:none;"> <label for="squeezeAlphaReSlider">Re(α) = <span id="squeezeAlphaReValue" class="param-display">2.0</span></label> <input type="range" id="squeezeAlphaReSlider" min="-4" max="4" value="2" step="0.1"> <label for="squeezeAlphaImSlider">Im(α) = <span id="squeezeAlphaImValue" class="param-display">0.0</span></label> <input type="range" id="squeezeAlphaImSlider" min="-4" max="4" value="0" step="0.1"> <label for="squeezeRSlider">Squeezing r = <span id="squeezeRValue" class="param-display">0.8</span></label> <input type="range" id="squeezeRSlider" min="-1.5" max="1.5" value="0.8" step="0.1"> </div>
            <div id="thermalControls" class="control-group" style="display:none;"> <label for="avgNSlider">Average Number &lt;n&gt; = <span id="avgNValue" class="param-display">1.0</span></label> <input type="range" id="avgNSlider" min="0.1" max="10" value="1.0" step="0.1"> </div>
            <div id="positionPlotControls" style="display: none;">
                <hr>
                <h2>Plot Visibility</h2>
                <div class="control-group toggle-group"> <label for="probCheck" id="prob-check-label"> <input type="checkbox" id="probCheck" checked> <span class="custom-checkbox"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></span> <span id="prob-label">|Ψ|²</span> </label> <label for="reCheck" id="re-check-label"> <input type="checkbox" id="reCheck" checked> <span class="custom-checkbox"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></span> <span id="re-label">Re(Ψ)</span> </label> <label for="imCheck" id="im-check-label"> <input type="checkbox" id="imCheck" checked> <span class="custom-checkbox"><svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg></span> <span id="im-label">Im(Ψ)</span> </label> </div>
            </div>
            <hr>
            <h2>Simulation Controls</h2>
            <div class="simulation-controls"> <button id="playPauseBtn" class="sim-button"><svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg><svg id="pauseIcon" style="display:none;" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg><span id="playPauseText">Play</span></button> <button id="resetBtn" class="sim-button"><svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z"/></svg><span>Reset Time</span></button> </div>
            <div id="timeDisplay">Time: <span id="timeValue" class="param-display">0.00</span></div>
        </aside>
    </main>
    <section class="explanation-wrapper">
        <div id="explanationToggle" class="explanation-toggle"> <span>What are these states & symbols?</span> <svg id="chevronIcon" viewBox="0 0 24 24"><path fill="currentColor" d="M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z"/></svg> </div>
        <div id="descriptionContainer">
            <h4>Understanding the Plots</h4>
            <p>You can switch between three different ways of looking at the quantum state:</p>
            <ul>
                 <li><strong>Phase Space Plot:</strong> This view shows the state in terms of both position (x-axis) and momentum (y-axis). The cloud of particles represents the <strong>Wigner quasi-probability distribution</strong>.
                    <ul>
                    <li>A dense cloud means a high probability of finding the particle with that combination of position and momentum.</li>
                    <li><span style="color: var(--highlight-color);">Red particles</span> indicate positive probability regions.</li>
                    <li><span style="color: var(--accent-color-1);">Blue particles</span> indicate "negative probability" regions, a purely quantum feature where the Wigner function is negative. Thermal states are always positive.</li>
                    </ul>
                </li>
                <li><strong>Number Space Plot:</strong> This shows the probability `P(n)` of finding the system in the n-th energy eigenstate (a "Number State" `|n>`).
                    <ul>
                    <li>The horizontal axis is the quantum number `n`, and the vertical axis is the probability.</li>
                    </ul>
                </li>
                <li><strong>Position Space Plot:</strong> This is the standard view of the wavefunction Ψ(x) at different positions x.
                    <ul>
                    <li><code style="color: var(--accent-color-3);">|Ψ|²</code> &mdash; <strong>Probability Density:</strong> Shows the probability of finding the particle at a certain position.</li>
                    <li><code style="color: var(--accent-color-1);">Re(Ψ)</code> &amp; <code style="color: var(--accent-color-2);">Im(Ψ)</code> &mdash; <strong>Real & Imaginary Parts:</strong> The two components of the complex wavefunction. Their oscillation drives the system's evolution. For thermal states, these are not shown as the state has no defined phase.</li>
                    </ul>
                </li>
            </ul>
            <h4>What are the states?</h4>
            <p><strong>Coherent State |α&gt;:</strong> A "quasi-classical" state. Its particle cloud in phase space is a simple circle that orbits the center, just like a classical pendulum. It has minimum uncertainty.</p>
            <p><strong>Squeezed State:</strong> A state where uncertainty in one variable (e.g., position) is reduced ("squeezed") at the expense of increasing the uncertainty in another (momentum). Its particle cloud in phase space is an ellipse that rotates and breathes as it orbits.</p>
            <p><strong>Number State |n&gt;:</strong> A stationary state with a definite energy. It has exactly `n` quanta of energy. Its phase space distribution is a static ring-like structure with prominent "negative probability" regions.</p>
            <p><strong>Thermal State:</strong> A <em>mixed state</em> representing a system in thermal equilibrium. It's an incoherent mixture of number states. In phase space, it's a circular, fuzzy blob centered at the origin, representing classical-like uncertainty due to heat. It is a stationary state whose width depends on the average number of quanta &lt;n&gt; (temperature).</p>
        </div>
    </section>

    <footer>
        <p>Created by <strong>Dr. Devender Garg</strong></p>
    </footer>

<script>
document.addEventListener('DOMContentLoaded', () => {
    // --- DOM Elements & State ---
    const canvasWrapper = document.querySelector('.canvas-wrapper');
    const qhoCanvas = document.getElementById('qhoCanvas'), qhoCtx = qhoCanvas.getContext('2d');
    const phaseCanvas = document.getElementById('phaseCanvas'), phaseCtx = phaseCanvas.getContext('2d');
    const numberCanvas = document.getElementById('numberCanvas'), numberCtx = numberCanvas.getContext('2d');
    const W = qhoCanvas.width, H = qhoCanvas.height;
    const stateButtons = document.querySelectorAll('.state-btn'), viewButtons = document.querySelectorAll('.view-btn');
    const probCheck = document.getElementById('probCheck'), reCheck = document.getElementById('reCheck'), imCheck = document.getElementById('imCheck');
    const reCheckLabel = document.getElementById('re-check-label'), imCheckLabel = document.getElementById('im-check-label');
    const playPauseBtn = document.getElementById('playPauseBtn'), resetBtn = document.getElementById('resetBtn'), playIcon = document.getElementById('playIcon'), pauseIcon = document.getElementById('pauseIcon'), playPauseText = document.getElementById('playPauseText');
    const controlGroups = { number: document.getElementById('numberControls'), coherent: document.getElementById('coherentControls'), squeezed: document.getElementById('squeezedControls'), thermal: document.getElementById('thermalControls') };
    const valueDisplays = { n: document.getElementById('nValue'), alphaRe: document.getElementById('alphaReValue'), alphaIm: document.getElementById('alphaImValue'), squeezeAlphaRe: document.getElementById('squeezeAlphaReValue'), squeezeAlphaIm: document.getElementById('squeezeAlphaImValue'), squeezeR: document.getElementById('squeezeRValue'), avgN: document.getElementById('avgNValue') };
    const descriptionContainer = document.getElementById('descriptionContainer'), timeValue = document.getElementById('timeValue'), explanationToggle = document.getElementById('explanationToggle'), timeDisplay = document.getElementById('timeDisplay');
    const allSliders = document.querySelectorAll('input[type="range"]');
    const computedStyles = getComputedStyle(document.documentElement), colors = { re: computedStyles.getPropertyValue('--accent-color-1').trim(), im: computedStyles.getPropertyValue('--accent-color-2').trim(), prob: computedStyles.getPropertyValue('--accent-color-3').trim(), highlight: computedStyles.getPropertyValue('--highlight-color').trim() };
    
    const simState = { time: 0, isRunning: false, userWantsToRun: false, animationFrameId: null, lastTimestamp: 0, currentState: 'coherent', currentView: 'phase' };
    const plotVisibility = { prob: true, re: true, im: true };
    const precomputedNumberStates = [];
    let cachedInitialParticles = null; 
    let cachedNumberData = null; 
    const MAX_N_PRECOMPUTE = 100; // Increased for higher <n>

    // --- Position Space Constants ---
    const xMin = -10, xMax = 10, yMin = -2, yMax = 12, numPoints = 600, dx = (xMax - xMin) / numPoints, WAVEFUNCTION_TARGET_HEIGHT = H / 4.5;
    // --- Phase Space Constants ---
    const pMin = -10, pMax = 10, NUM_PARTICLES = 6000;
    
    // --- Math & Physics Calculations ---
    const C = { mag2: (c) => c.re * c.re + c.im * c.im };
    function laguerreL(n, x) {
        if (n === 0) return 1; if (n === 1) return 1 - x;
        let l_prev = 1, l_curr = 1 - x;
        for (let i = 2; i <= n; i++) { const l_next = ((2 * i - 1 - x) * l_curr - (i - 1) * l_prev) / i; l_prev = l_curr; l_curr = l_next; }
        return l_curr;
    }
    function precomputeAllNumberStates(maxN) {
        const x_grid = Array.from({length: numPoints}, (_, i) => xMin + i * dx);
        const pi_inv_fourth = Math.pow(Math.PI, -0.25);
        precomputedNumberStates[0] = x_grid.map(x => pi_inv_fourth * Math.exp(-x * x / 2));
        if (maxN === 0) return;
        precomputedNumberStates[1] = x_grid.map((x, i) => Math.sqrt(2) * x * precomputedNumberStates[0][i]);
        for (let n = 1; n < maxN; n++) {
            if (!precomputedNumberStates[n]) continue;
            const psi_n_minus_1 = precomputedNumberStates[n];
            const psi_n_minus_2 = precomputedNumberStates[n - 1];
            precomputedNumberStates[n + 1] = x_grid.map((x, i) => Math.sqrt(2 / (n + 1)) * x * psi_n_minus_1[i] - Math.sqrt(n / (n + 1)) * psi_n_minus_2[i]);
        }
    }
    function calculateWavefunction(params, t) {
        if (params.type === 'thermal') {
            const avgN = params.avgN;
            if (avgN < 1e-6) return { is_mixed_state: true, prob_density: precomputedNumberStates[0].map(val => val * val) };
            const beta = Math.log(1 + 1 / avgN);
            let probabilities = Array(MAX_N_PRECOMPUTE + 1).fill(0).map((_, n) => Math.exp(-n * beta));
            const sumP = probabilities.reduce((a, b) => a + b, 0);
            probabilities = probabilities.map(p => p / sumP);
            const prob_density = Array(numPoints).fill(0);
            for (let i = 0; i < numPoints; i++) {
                for (let n = 0; n <= MAX_N_PRECOMPUTE; n++) {
                    const psi_n_val = precomputedNumberStates[n]?.[i] ?? 0;
                    prob_density[i] += probabilities[n] * psi_n_val * psi_n_val;
                }
            }
            return { is_mixed_state: true, prob_density: prob_density };
        } else if (params.type === 'number') {
            const psi_n_spatial = precomputedNumberStates[params.n];
            const phase = -(params.n + 0.5) * t;
            return psi_n_spatial.map(val => ({ re: val * Math.cos(phase), im: val * Math.sin(phase) }));
        } else {
            const x0 = Math.sqrt(2)*params.alphaRe, p0 = Math.sqrt(2)*params.alphaIm, r = params.r;
            const xt = x0*Math.cos(t) + p0*Math.sin(t), pt = p0*Math.cos(t) - x0*Math.sin(t);
            const cosh2r = Math.cosh(2*r), sinh2r = Math.sinh(2*r), cos2t = Math.cos(2*t);
            const sigma_x_sq_t = 0.5 * (cosh2r - sinh2r*cos2t);
            const b_t = sigma_x_sq_t ? -0.5*sinh2r*Math.sin(2*t)/sigma_x_sq_t : 0;
            let psi = Array(numPoints).fill({ re: 0, im: 0 }).map((_, i) => { const x = xMin+i*dx, dx_val = x-xt; const mag_term = Math.exp(-dx_val*dx_val/(4*sigma_x_sq_t)); const phase_term = pt*x + 0.5*b_t*dx_val*dx_val; return { re: mag_term*Math.cos(phase_term), im: mag_term*Math.sin(phase_term) }; });
            const normFactor = 1 / Math.sqrt(psi.reduce((sum, p) => sum + C.mag2(p) * dx, 0) || 1);
            return psi.map(p => ({ re: p.re*normFactor, im: p.im*normFactor }));
        }
    }
    function calculateNumberStateProbabilities(params) {
        if (cachedNumberData) return cachedNumberData;

        const probabilities = new Array(MAX_N_PRECOMPUTE + 1).fill(0);
        if (params.type === 'number') {
            if (params.n <= MAX_N_PRECOMPUTE) probabilities[params.n] = 1;
        } else if (params.type === 'thermal') {
            const avgN = params.avgN;
            if (avgN < 1e-6) { probabilities[0] = 1; }
            else {
                const beta = Math.log(1 + 1 / avgN);
                let p_unnormalized = probabilities.map((_, n) => Math.exp(-n * beta));
                const sumP = p_unnormalized.reduce((a, b) => a + b, 0);
                for(let n=0; n<probabilities.length; n++) probabilities[n] = p_unnormalized[n]/sumP;
            }
        } else { 
            const psi_t0 = calculateWavefunction(params, 0); 
            for (let n = 0; n <= MAX_N_PRECOMPUTE; n++) {
                let overlap = { re: 0, im: 0 };
                const psi_n = precomputedNumberStates[n];
                if (!psi_n) continue;
                for (let i = 0; i < numPoints; i++) {
                    overlap.re += psi_n[i] * psi_t0[i].re * dx;
                    overlap.im += psi_n[i] * psi_t0[i].im * dx;
                }
                probabilities[n] = C.mag2(overlap);
            }
        }
        
        let mean_n = 0;
        let mean_n_squared = 0;
        for (let n = 0; n < probabilities.length; n++) {
            const p = probabilities[n] || 0;
            mean_n += n * p;
            mean_n_squared += n * n * p;
        }
        const variance_n = mean_n_squared - mean_n * mean_n;
        
        const numberData = { probabilities, mean: mean_n, variance: variance_n };
        cachedNumberData = numberData;
        return numberData;
    }
    function getWignerFunction(params, t) {
        const { type, n, alphaRe, alphaIm, r, avgN } = params;
        const x0 = Math.sqrt(2) * alphaRe, p0 = Math.sqrt(2) * alphaIm;
        const xt = x0 * Math.cos(t) + p0 * Math.sin(t), pt = p0 * Math.cos(t) - x0 * Math.sin(t);

        if (type === 'number') return (x, p) => ((-1)**n / Math.PI) * Math.exp(-(x*x + p*p)) * laguerreL(n, 2*(x*x+p*p));
        if (type === 'thermal') {
            if (avgN < 1e-6) return (x, p) => (1 / Math.PI) * Math.exp(-(x * x + p * p));
            const beta = Math.log(1 + 1 / avgN), tanh_beta_half = Math.tanh(beta / 2);
            return (x, p) => (tanh_beta_half / Math.PI) * Math.exp(-tanh_beta_half * (x * x + p * p));
        }
        const cosh2r = Math.cosh(2*r), sinh2r = Math.sinh(2*r), cos2t = Math.cos(2*t), sin2t = Math.sin(2*t);
        const var_x = 0.5 * (cosh2r - sinh2r * cos2t), var_p = 0.5 * (cosh2r + sinh2r * cos2t), cov_xp = -0.5 * sinh2r * sin2t;
        const det = var_x * var_p - cov_xp * cov_xp, norm = 1 / (2 * Math.PI * Math.sqrt(det || 0.25));
        return (x, p) => norm * Math.exp(-0.5 / det * (var_p * (x-xt)**2 + var_x * (p-pt)**2 - 2 * cov_xp * (x-xt) * (p-pt)));
    }
    function generateParticlesFromWigner(W, numParticles, wMaxEstimate = 0.4) {
        const particles = [];
        for (let attempts = 0; particles.length < numParticles && attempts < numParticles * 100; attempts++) {
            const x = xMin + Math.random() * (xMax - xMin), p = pMin + Math.random() * (pMax - pMin);
            const w_val = W(x, p);
            if (Math.random() * wMaxEstimate < Math.abs(w_val)) particles.push({ x0: x, p0: p, isPositive: w_val >= 0 });
        }
        return particles;
    }

    // --- Drawing Functions ---
    function drawPositionScene() { qhoCtx.fillStyle = '#0c0c14'; qhoCtx.fillRect(0, 0, W, H); qhoCtx.strokeStyle = '#444'; qhoCtx.lineWidth = 2; qhoCtx.beginPath(); for (let i = 0; i < W; i++) { const x = xMin + i/W * (xMax - xMin), V = 0.5*x*x; if (i === 0) qhoCtx.moveTo(i, H - (V - yMin) / (yMax - yMin) * H); else qhoCtx.lineTo(i, H - (V - yMin) / (yMax - yMin) * H); } qhoCtx.stroke(); qhoCtx.strokeStyle = '#333'; qhoCtx.lineWidth = 1; qhoCtx.beginPath(); qhoCtx.moveTo(0, H - (0 - yMin) / (yMax - yMin) * H); qhoCtx.lineTo(W, H - (0 - yMin) / (yMax - yMin) * H); qhoCtx.stroke(); }
    function drawWavefunction(psi_data, params) {
        const toScreenY = y => H - (y - yMin) / (yMax - yMin) * H;
        if (psi_data.is_mixed_state) {
            const prob_density = psi_data.prob_density, maxProb = Math.max(...prob_density, 1e-9);
            const yScaleProb = (WAVEFUNCTION_TARGET_HEIGHT / maxProb) * ((yMax - yMin) / H);
            if (plotVisibility.prob) { qhoCtx.fillStyle = `${colors.prob}99`; qhoCtx.beginPath(); qhoCtx.moveTo(0, toScreenY(0)); prob_density.forEach((p, i) => qhoCtx.lineTo(i/numPoints*W, toScreenY(p * yScaleProb))); qhoCtx.lineTo(W, toScreenY(0)); qhoCtx.closePath(); qhoCtx.fill(); }
        } else {
            const stationary_psi_t0 = calculateWavefunction(params, 0);
            const maxAmplitude = Math.sqrt(Math.max(...stationary_psi_t0.map(C.mag2), 1e-9));
            const yScaleWF = (WAVEFUNCTION_TARGET_HEIGHT / maxAmplitude) * ((yMax - yMin) / H);
            if (plotVisibility.prob) { const yScaleProb = yScaleWF**2; qhoCtx.fillStyle = `${colors.prob}99`; qhoCtx.beginPath(); qhoCtx.moveTo(0, toScreenY(0)); psi_data.forEach((p, i) => qhoCtx.lineTo(i/numPoints*W, toScreenY(C.mag2(p) * yScaleProb))); qhoCtx.lineTo(W, toScreenY(0)); qhoCtx.closePath(); qhoCtx.fill(); }
            if (plotVisibility.re) { qhoCtx.strokeStyle = colors.re; qhoCtx.lineWidth = 2; qhoCtx.beginPath(); psi_data.forEach((p, i) => { if (i===0) qhoCtx.moveTo(i/numPoints*W, toScreenY(p.re*yScaleWF)); else qhoCtx.lineTo(i/numPoints*W, toScreenY(p.re*yScaleWF)); }); qhoCtx.stroke(); }
            if (plotVisibility.im) { qhoCtx.strokeStyle = colors.im; qhoCtx.lineWidth = 2; qhoCtx.beginPath(); psi_data.forEach((p, i) => { if (i===0) qhoCtx.moveTo(i/numPoints*W, toScreenY(p.im*yScaleWF)); else qhoCtx.lineTo(i/numPoints*W, toScreenY(p.im*yScaleWF)); }); qhoCtx.stroke(); }
        }
    }
    function drawPhaseSpaceScene() { 
        phaseCtx.fillStyle = '#0c0c14'; phaseCtx.fillRect(0, 0, W, H); 
        phaseCtx.strokeStyle = '#333'; phaseCtx.lineWidth = 1; 
        const toX=x=>(x-xMin)/(xMax-xMin)*W, toY=p=>H-(p-pMin)/(pMax-pMin)*H; 
        phaseCtx.beginPath(); phaseCtx.moveTo(toX(xMin), toY(0)); phaseCtx.lineTo(toX(xMax), toY(0)); phaseCtx.stroke(); 
        phaseCtx.beginPath(); phaseCtx.moveTo(toX(0), toY(pMin)); phaseCtx.lineTo(toX(0), toY(pMax)); phaseCtx.stroke(); 
        phaseCtx.font = "16px monospace"; 
        phaseCtx.fillStyle = '#ccc'; 
        phaseCtx.textAlign = 'start';
        phaseCtx.fillText("x (position)", W - 120, toY(0) - 15); 
        phaseCtx.fillText("p (momentum)", toX(0) + 15, 25); 
    }
    function drawPhaseSpaceParticles(particles) { const posCol = `${colors.highlight}b3`, negCol = `${colors.re}b3`; const toX=x=>(x-xMin)/(xMax-xMin)*W, toY=p=>H-(p-pMin)/(pMax-pMin)*H; for (const p of particles) { phaseCtx.fillStyle = p.isPositive ? posCol : negCol; phaseCtx.fillRect(toX(p.x), toY(p.p), 2, 2); } }
    
    // --- MODIFICATION START: Entire function updated for dynamic axes ---
    function drawNumberSpace(numberData) {
        const { probabilities, mean, variance } = numberData;
        const padding = 60;

        // --- DYNAMIC AXIS LOGIC ---
        // Dynamic X-Axis
        const max_n_display = Math.max(25, Math.ceil(mean) + 15);
        
        // Dynamic Y-Axis
        const maxProb = Math.max(...probabilities, 0);
        const yMax = maxProb < 0.5 ? 0.5 : 1.0;
        
        numberCtx.fillStyle = '#0c0c14'; numberCtx.fillRect(0, 0, W, H);
        numberCtx.strokeStyle = '#333'; numberCtx.lineWidth = 1;
        numberCtx.beginPath(); numberCtx.moveTo(padding, H-padding); numberCtx.lineTo(W-padding, H-padding); numberCtx.stroke();

        numberCtx.font = "16px monospace"; 
        numberCtx.fillStyle = '#ccc'; 
        numberCtx.textAlign = 'center';
        numberCtx.fillText("n (Quantum Number)", W/2, H - padding/3);
        numberCtx.save(); numberCtx.translate(padding/3, H/2); numberCtx.rotate(-Math.PI/2); numberCtx.fillText("P(n) (Probability)", 0, 0); numberCtx.restore();

        // Draw Y-axis tick marks and labels based on dynamic yMax
        const yTicks = [0, 0.25 * yMax, 0.5 * yMax, 0.75 * yMax, yMax];
        const drawableHeight = H - 2 * padding;
        yTicks.forEach(probValue => {
            const y = (H - padding) - (probValue / yMax) * drawableHeight;
            numberCtx.beginPath();
            numberCtx.moveTo(padding - 5, y);
            numberCtx.lineTo(padding, y);
            numberCtx.strokeStyle = '#888';
            numberCtx.lineWidth = 1;
            numberCtx.stroke();

            numberCtx.fillStyle = '#888';
            numberCtx.font = "12px sans-serif";
            numberCtx.textAlign = 'right';
            numberCtx.textBaseline = 'middle';
            numberCtx.fillText(probValue.toFixed(2), padding - 10, y);
        });

        // Draw bars with dynamic scaling
        const barWidth = (W - 2*padding) / (max_n_display + 1);
        for (let n = 0; n <= max_n_display; n++) {
            const prob = probabilities[n] || 0;
            const barHeight = (prob / yMax) * drawableHeight;
            const x = padding + n * barWidth;
            
            numberCtx.fillStyle = colors.highlight;
            if (barHeight > 0.5) numberCtx.fillRect(x, H - padding - barHeight, barWidth * 0.8, barHeight);
            
            if (n % 5 === 0 || (max_n_display < 30 && n % 2 === 0)) {
                 numberCtx.fillStyle = '#888';
                 numberCtx.font = "14px sans-serif";
                 numberCtx.textAlign = 'center';
                 numberCtx.fillText(n, x + barWidth*0.4, H - padding + 20);
            }
        }

        numberCtx.fillStyle = '#ccc';
        numberCtx.font = "16px monospace";
        numberCtx.textAlign = 'right';
        const textX = W - padding;
        const textY1 = padding;
        numberCtx.fillText(`Mean <n>  = ${mean.toFixed(2)}`, textX, textY1);
        numberCtx.fillText(`Var (Δn)² = ${variance.toFixed(2)}`, textX, textY1 + 22);
    }
    // --- MODIFICATION END ---
    
    // --- Main Loop & Update Logic ---
    function getCurrentParams() { const type = simState.currentState; switch(type) { case 'number': return { type, n: parseInt(document.getElementById('nSlider').value) }; case 'coherent': return { type, alphaRe: parseFloat(document.getElementById('alphaReSlider').value), alphaIm: parseFloat(document.getElementById('alphaImSlider').value), r: 0 }; case 'squeezed': return { type, alphaRe: parseFloat(document.getElementById('squeezeAlphaReSlider').value), alphaIm: parseFloat(document.getElementById('squeezeAlphaImSlider').value), r: parseFloat(document.getElementById('squeezeRSlider').value) }; case 'thermal': return { type, avgN: parseFloat(document.getElementById('avgNSlider').value) }; } }
    
    function updateUIValues() {
        const params = getCurrentParams();
        valueDisplays.n.textContent = (params.n ?? 0).toFixed(0);
        valueDisplays.alphaRe.textContent = (params.alphaRe ?? 0).toFixed(1);
        valueDisplays.alphaIm.textContent = (params.alphaIm ?? 0).toFixed(1);
        valueDisplays.squeezeAlphaRe.textContent = (params.alphaRe ?? 0).toFixed(1);
        valueDisplays.squeezeAlphaIm.textContent = (params.alphaIm ?? 0).toFixed(1);
        valueDisplays.squeezeR.textContent = (params.r ?? 0).toFixed(1);
        valueDisplays.avgN.textContent = (params.avgN ?? 0).toFixed(1);
        timeValue.textContent = simState.time.toFixed(2);
    }
    
    function redrawCurrentState() {
        const params = getCurrentParams(); updateUIValues();
        if (simState.currentView === 'position') { const psi_data = calculateWavefunction(params, simState.time); drawPositionScene(); drawWavefunction(psi_data, params); } 
        else if (simState.currentView === 'phase') {
            if (cachedInitialParticles === null) { const Wigner_t0 = getWignerFunction(params, 0); cachedInitialParticles = generateParticlesFromWigner(Wigner_t0, NUM_PARTICLES); }
            const isStationary = params.type === 'number' || params.type === 'thermal';
            const particles = isStationary ? cachedInitialParticles.map(p => ({...p, x: p.x0, p: p.p0})) : cachedInitialParticles.map(p => ({...p, x: p.x0*Math.cos(simState.time)+p.p0*Math.sin(simState.time), p: p.p0*Math.cos(simState.time)-p.x0*Math.sin(simState.time)}));
            drawPhaseSpaceScene(); drawPhaseSpaceParticles(particles);
        } else if (simState.currentView === 'number') { 
            const numberData = calculateNumberStateProbabilities(params);
            drawNumberSpace(numberData);
        }
    }
    
    function simulationLoop(timestamp) { if (!simState.isRunning) return; const deltaTime = (timestamp - simState.lastTimestamp)/1000; simState.lastTimestamp = timestamp; simState.time += deltaTime * 2.0; redrawCurrentState(); simState.animationFrameId = requestAnimationFrame(simulationLoop); }
    
    // --- Event Handlers ---
    function invalidateCache() { 
        cachedInitialParticles = null; 
        cachedNumberData = null;
    }
    function playSimulation() { if (simState.isRunning) return; simState.isRunning = true; playPauseText.textContent = 'Pause'; playIcon.style.display = 'none'; pauseIcon.style.display = 'block'; simState.lastTimestamp = performance.now(); simState.animationFrameId = requestAnimationFrame(simulationLoop); }
    function pauseSimulation() { if (!simState.isRunning) return; simState.isRunning = false; playPauseText.textContent = 'Play'; playIcon.style.display = 'block'; pauseIcon.style.display = 'none'; cancelAnimationFrame(simState.animationFrameId); }
    
    function isEffectivelyStationary() {
        const state = simState.currentState, view = simState.currentView;
        if (view === 'number' || state === 'number' || state === 'thermal') return true;
        return false;
    }
    
    function togglePlayPause() { if (isEffectivelyStationary()) return; simState.isRunning ? (simState.userWantsToRun = false, pauseSimulation()) : (simState.userWantsToRun = true, playSimulation()); }
    function resetTime() { simState.time = 0; if (!simState.isRunning) redrawCurrentState(); }
    
    function updateControlAvailability() {
        const isStationary = isEffectivelyStationary();
        playPauseBtn.disabled = isStationary; resetBtn.disabled = isStationary; timeDisplay.style.visibility = isStationary ? 'hidden' : 'visible';
        if (isStationary) { pauseSimulation(); resetTime(); }
    }

    function handleStateChange(newState) {
        simState.currentState = newState; invalidateCache();
        stateButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.state === newState));
        Object.keys(controlGroups).forEach(key => controlGroups[key].style.display = (key === newState) ? 'block' : 'none');
        
        const isThermal = newState === 'thermal';
        reCheck.disabled = isThermal; reCheckLabel.classList.toggle('disabled', isThermal);
        imCheck.disabled = isThermal; imCheckLabel.classList.toggle('disabled', isThermal);
        if (isThermal) { reCheck.checked = false; imCheck.checked = false; plotVisibility.re = false; plotVisibility.im = false; }

        updateControlAvailability();
        if (!isEffectivelyStationary() && simState.userWantsToRun) playSimulation();
        if (!simState.isRunning) redrawCurrentState();
    }
    
    function handleViewChange(newView) {
        simState.currentView = newView; invalidateCache();
        viewButtons.forEach(btn => btn.classList.toggle('active', btn.dataset.view === newView));
        qhoCanvas.style.display = newView === 'position' ? 'block' : 'none';
        phaseCanvas.style.display = newView === 'phase' ? 'block' : 'none';
        numberCanvas.style.display = newView === 'number' ? 'block' : 'none';
        document.querySelector('.plot-labels').style.display = newView === 'position' ? 'flex' : 'none';
        document.getElementById('positionPlotControls').style.display = newView === 'position' ? 'block' : 'none';

        updateControlAvailability();
        if (!isEffectivelyStationary() && simState.userWantsToRun) playSimulation();
        if (!simState.isRunning) redrawCurrentState();
    }

    playPauseBtn.addEventListener('click', togglePlayPause);
    resetBtn.addEventListener('click', resetTime);
    canvasWrapper.addEventListener('click', togglePlayPause);
    stateButtons.forEach(button => button.addEventListener('click', () => handleStateChange(button.dataset.state)));
    viewButtons.forEach(button => button.addEventListener('click', () => handleViewChange(button.dataset.view)));
    allSliders.forEach(slider => { slider.addEventListener('input', () => { invalidateCache(); if (!simState.isRunning) redrawCurrentState(); else updateUIValues(); }); });
    [probCheck, reCheck, imCheck].forEach(check => { check.addEventListener('change', () => { plotVisibility.prob = probCheck.checked; plotVisibility.re = reCheck.checked; plotVisibility.im = imCheck.checked; if (!simState.isRunning) redrawCurrentState(); }); });
    explanationToggle.addEventListener('click', () => { explanationToggle.classList.toggle('is-open'); descriptionContainer.classList.toggle('is-visible'); descriptionContainer.style.maxHeight = descriptionContainer.style.maxHeight ? null : descriptionContainer.scrollHeight + "px"; });

    // --- Initialization ---
    precomputeAllNumberStates(MAX_N_PRECOMPUTE);
    handleViewChange('phase');
    handleStateChange('coherent');
    simState.userWantsToRun = true; 
    playSimulation();
});
</script>

</body>
</html>