<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hydrogen Atom Orbitals with 2D Cross-Sections</title>

    <style>
        html, body {
            min-height: 100vh;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #111;
            color: #eee;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }
        
        #canvas-container {
            height: 65vh;
            min-height: 400px;
            width: 100%;
            position: relative;
        }
        #canvas-container canvas {
            display: block;
        }

        #ui-container {
            padding: 15px;
            background-color: #222;
            text-align: center;
            border-top: 2px solid #555;
            border-bottom: 2px solid #555;
            flex-shrink: 0;
        }
        #orbital-select {
            padding: 8px;
            font-size: 1.1em;
            border-radius: 5px;
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
        }
        #filter-container {
            margin-top: 12px;
            font-size: 0.9em;
        }
        #filter-container label {
            margin: 0 10px;
            cursor: pointer;
        }
        #orbital-info {
            margin-top: 10px;
            font-size: 0.9em;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.4;
        }

        #cross-section-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            background-color: #1a1a1a;
            padding: 20px 10px;
            gap: 20px;
        }
        .cross-section-view {
            text-align: center;
        }
        .cross-section-view h3 {
            margin: 0 0 5px 0;
            font-weight: normal;
            font-size: 0.9em;
        }
        .cross-section-view canvas {
            background-color: #000;
            border: 1px solid #444;
            max-width: 100%;
        }

        #info {
            position: absolute;
            top: 15px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.6);
            border-radius: 5px;
            max-width: 300px;
            pointer-events: none;
        }
        h1 {
            margin: 0 0 10px 0;
            font-size: 1.2em;
        }
        p {
            margin: 5px 0;
            font-size: 0.9em;
        }
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            color: #000;
            border-radius: 10px;
            font-size: 1.5em;
            z-index: 100;
        }
        #credits {
            position: absolute;
            bottom: 10px;
            right: 15px;
            color: #aaa;
            font-size: 12px;
            font-style: italic;
            pointer-events: none;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- 3D simulation area -->
    <div id="canvas-container">
        <div id="info">
            <h1>Hydrogen Atom Electron Clouds</h1>
            <p>Visualizing the probability density |ψ|² for an electron in a hydrogen atom.</p>
            <p>Positive lobes of the wave function (ψ) are colored <span style="color:#ff8000;">orange</span>, negative lobes are <span style="color:#00bfff;">cyan</span>.</p>
        </div>
        <div id="loader" class="hidden">Generating...</div>
        <div id="credits">Created by Dr. Devender Garg</div>
    </div>
    
    <!-- UI controls area -->
    <div id="ui-container">
        <label for="orbital-select">Select Orbital:</label>
        <select id="orbital-select">
            <option value="1s" selected>1s</option>
            <option value="2s">2s</option>
            <option value="2px">2p_x</option>
            <option value="2py">2p_y</option>
            <option value="2pz">2p_z</option>
            <option value="3s">3s</option>
            <option value="3px">3p_x</option>
            <option value="3py">3p_y</option>
            <option value="3pz">3p_z</option>
            <option value="3d_z2">3d_{z^2}</option>
            <option value="3d_xz">3d_{xz}</option>
            <option value="3d_yz">3d_{yz}</option>
            <option value="3d_xy">3d_{xy}</option>
            <option value="3d_x2-y2">3d_{x^2-y^2}</option>
        </select>
        <div id="filter-container">
            <label>
                <input type="checkbox" id="positive-checkbox" checked> Show Positive (Orange)
            </label>
            <label>
                <input type="checkbox" id="negative-checkbox" checked> Show Negative (Cyan)
            </label>
        </div>
        <div id="orbital-info"></div>
    </div>

    <!-- 2D cross-sections area -->
    <div id="cross-section-container">
        <div class="cross-section-view">
            <h3>XY Plane (at z=0)</h3>
            <canvas id="xy-canvas" width="300" height="300"></canvas>
        </div>
        <div class="cross-section-view">
            <h3>XZ Plane (at y=0)</h3>
            <canvas id="xz-canvas" width="300" height="300"></canvas>
        </div>
        <div class="cross-section-view">
            <h3>YZ Plane (at x=0)</h3>
            <canvas id="yz-canvas" width="300" height="300"></canvas>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const NUM_POINTS_3D = 75000;
        const NUM_POINTS_2D = 25000;
        const AXIS_LENGTH = 25;
        let scene, camera, renderer, controls, points;
        let allPositions = [], allColors = [];
        
        // Cache to store generated orbital data
        const orbitalCache = {};

        const canvasContainer = document.getElementById('canvas-container');
        const canvas2D = {
            xy: document.getElementById('xy-canvas'),
            xz: document.getElementById('xz-canvas'),
            yz: document.getElementById('yz-canvas')
        };
        const ctx2D = {
            xy: canvas2D.xy.getContext('2d'),
            xz: canvas2D.xz.getContext('2d'),
            yz: canvas2D.yz.getContext('2d')
        };

        const loader = document.getElementById('loader');
        const orbitalSelect = document.getElementById('orbital-select');
        const orbitalInfoDiv = document.getElementById('orbital-info');
        const positiveCheckbox = document.getElementById('positive-checkbox');
        const negativeCheckbox = document.getElementById('negative-checkbox');

        const waveFunctions = { /* ... (wave functions are unchanged) ... */ '1s': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = Math.exp(-r); return { val: val, prob: val*val }; }, '2s': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (2 - r) * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '2px': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = x * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '2py': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = y * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '2pz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = z * Math.exp(-r / 2); return { val: val, prob: val*val }; }, '3s': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (27 - 18 * r + 2 * r * r) * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3px': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (6 - r) * x * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3py': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (6 - r) * y * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3pz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (6 - r) * z * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_z2': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); if (r === 0) return { val: 0, prob: 0 }; const cosTheta = z / r; const val = (3 * cosTheta * cosTheta - 1) * r*r * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_xz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = x * z * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_yz': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = y * z * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_xy': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = x * y * Math.exp(-r / 3); return { val: val, prob: val*val }; }, '3d_x2-y2': (x, y, z) => { const r = Math.sqrt(x*x + y*y + z*z); const val = (x * x - y * y) * Math.exp(-r / 3); return { val: val, prob: val*val }; } };
        const orbitalProperties = { /* ... (orbital properties are unchanged) ... */ '1s': { n: 1, l: 0, m: 0, maxProb: 1.0, boxSize: 15 }, '2s': { n: 2, l: 0, m: 0, maxProb: 4.0, boxSize: 25 }, '2px': { n: 2, l: 1, m: '±1',maxProb: 0.6, boxSize: 25 }, '2py': { n: 2, l: 1, m: '±1',maxProb: 0.6, boxSize: 25 }, '2pz': { n: 2, l: 1, m: 0, maxProb: 0.6, boxSize: 25 }, '3s': { n: 3, l: 0, m: 0, maxProb: 730.0, boxSize: 45 }, '3px': { n: 3, l: 1, m: '±1',maxProb: 15.0, boxSize: 45 }, '3py': { n: 3, l: 1, m: '±1',maxProb: 15.0, boxSize: 45 }, '3pz': { n: 3, l: 1, m: 0, maxProb: 15.0, boxSize: 45 }, '3d_z2': { n: 3, l: 2, m: 0, maxProb: 12.0, boxSize: 45 }, '3d_xz': { n: 3, l: 2, m: '±1',maxProb: 3.0, boxSize: 45 }, '3d_yz': { n: 3, l: 2, m: '±1',maxProb: 3.0, boxSize: 45 }, '3d_xy': { n: 3, l: 2, m: '±2',maxProb: 3.0, boxSize: 45 }, '3d_x2-y2':{ n: 3, l: 2, m: '±2',maxProb: 3.0, boxSize: 45 } };
        
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
            camera.position.z = 65; 

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(0, 8, 0); 
            controls.enableDamping = true;
            
            const axesHelper = new THREE.AxesHelper(AXIS_LENGTH);
            scene.add(axesHelper);
            
            const labelX = createAxisLabel('X', new THREE.Vector3(AXIS_LENGTH + 2, 0, 0), '#FF4444');
            const labelY = createAxisLabel('Y', new THREE.Vector3(0, AXIS_LENGTH + 2, 0), '#44FF44');
            const labelZ = createAxisLabel('Z', new THREE.Vector3(0, 0, AXIS_LENGTH + 2), '#4444FF');
            scene.add(labelX, labelY, labelZ);

            // Create the points object once and add it to the scene
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7, depthWrite: false });
            points = new THREE.Points(geometry, material);
            scene.add(points);
            
            window.addEventListener('resize', onWindowResize, false);
            orbitalSelect.addEventListener('change', (event) => updateOrbital(event.target.value));
            positiveCheckbox.addEventListener('change', applyColorFilter);
            negativeCheckbox.addEventListener('change', applyColorFilter);
            
            updateOrbital(orbitalSelect.value);
            animate();
        }
        
        function createAxisLabel(text, position, color) { /* ... (function unchanged) ... */ const canvas = document.createElement('canvas'); const context = canvas.getContext('2d'); const size = 64; canvas.width = size; canvas.height = size; context.font = `Bold 40px Arial`; context.fillStyle = color; context.textAlign = 'center'; context.textBaseline = 'middle'; context.fillText(text, size / 2, size / 2); const texture = new THREE.CanvasTexture(canvas); const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true }); const sprite = new THREE.Sprite(spriteMaterial); sprite.position.copy(position); sprite.scale.set(3, 3, 1.0); return sprite; }

        function generateOrbitalCloud3D(orbitalName) { /* ... (function unchanged) ... */ const props = orbitalProperties[orbitalName]; const waveFunc = waveFunctions[orbitalName]; const maxProb = props.maxProb; const boxSize = props.boxSize; const positions = []; const colors = []; const colorPositive = new THREE.Color(0xff8000); const colorNegative = new THREE.Color(0x00bfff); let pointsFound = 0; let attempts = 0; const maxAttempts = 20000000; while (pointsFound < NUM_POINTS_3D && attempts < maxAttempts) { const x = (Math.random() - 0.5) * boxSize; const y = (Math.random() - 0.5) * boxSize; const z = (Math.random() - 0.5) * boxSize; const { val, prob } = waveFunc(x, y, z); if (Math.random() < prob / maxProb) { positions.push(x, y, z); const color = (val > 0) ? colorPositive : colorNegative; colors.push(color.r, color.g, color.b); pointsFound++; } attempts++; } if (attempts >= maxAttempts) console.warn(`3D Generation stopped for ${orbitalName}.`); return { positions, colors }; }
        function generate2DCrossSectionData(orbitalName, plane) { /* ... (function unchanged) ... */ const props = orbitalProperties[orbitalName]; const waveFunc = waveFunctions[orbitalName]; const maxProb = props.maxProb; const boxSize = props.boxSize; const points2D = []; let pointsFound = 0; let attempts = 0; const maxAttempts = NUM_POINTS_2D * 1000; while (pointsFound < NUM_POINTS_2D && attempts < maxAttempts) { const u = (Math.random() - 0.5) * boxSize; const v = (Math.random() - 0.5) * boxSize; let x=0, y=0, z=0; if (plane === 'xy') { x = u; y = v; z = 0; } else if (plane === 'xz') { x = u; z = v; y = 0; } else if (plane === 'yz') { y = u; z = v; x = 0; } const { val, prob } = waveFunc(x, y, z); if (Math.random() < prob / maxProb) { points2D.push({u, v, val}); pointsFound++; } attempts++; } return points2D; }
        function drawSlice(ctx, data, boxSize) { /* ... (function unchanged) ... */ const canvas = ctx.canvas; const w = canvas.width; const h = canvas.height; const particleSize = 1; ctx.clearRect(0, 0, w, h); const colorPositive = 'rgb(255, 128, 0)'; const colorNegative = 'rgb(0, 191, 255)'; for (const p of data) { const pixelX = (p.u / boxSize + 0.5) * w; const pixelY = (-p.v / boxSize + 0.5) * h; ctx.fillStyle = (p.val > 0) ? colorPositive : colorNegative; ctx.fillRect(pixelX, pixelY, particleSize, particleSize); } }

        function applyColorFilter() {
            if (!points || allPositions.length === 0) return;
            const showPositive = positiveCheckbox.checked;
            const showNegative = negativeCheckbox.checked;
            const filteredPositions = [];
            const filteredColors = [];
            for (let i = 0; i < allColors.length; i += 3) {
                const isPositive = allColors[i] > allColors[i+1]; 
                if ((isPositive && showPositive) || (!isPositive && showNegative)) {
                    filteredPositions.push(allPositions[i], allPositions[i+1], allPositions[i+2]);
                    filteredColors.push(allColors[i], allColors[i+1], allColors[i+2]);
                }
            }
            points.geometry.setAttribute('position', new THREE.Float32BufferAttribute(filteredPositions, 3));
            points.geometry.setAttribute('color', new THREE.Float32BufferAttribute(filteredColors, 3));
            points.geometry.attributes.position.needsUpdate = true;
            points.geometry.attributes.color.needsUpdate = true;
            points.geometry.computeBoundingSphere();
        }

        function updateOrbital(orbitalName) {
            const props = orbitalProperties[orbitalName];
            orbitalInfoDiv.innerHTML = `Quantum Numbers:<br>n = ${props.n}<br>l = ${props.l}<br>m = ${props.m}`;

            // Check if data is in the cache
            if (orbitalCache[orbitalName]) {
                console.log(`Loading ${orbitalName} from cache.`);
                const cachedData = orbitalCache[orbitalName];
                
                // Use cached data
                allPositions = cachedData.pointCloud3D.positions;
                allColors = cachedData.pointCloud3D.colors;
                applyColorFilter();
                
                drawSlice(ctx2D.xy, cachedData.crossSections2D.xy, props.boxSize);
                drawSlice(ctx2D.xz, cachedData.crossSections2D.xz, props.boxSize);
                drawSlice(ctx2D.yz, cachedData.crossSections2D.yz, props.boxSize);

                return; // Exit the function early
            }

            // If not in cache, generate it
            console.log(`Generating and caching ${orbitalName}.`);
            loader.classList.remove('hidden');

            setTimeout(() => {
                // Generate all data
                const pointCloud3D = generateOrbitalCloud3D(orbitalName);
                const dataXY = generate2DCrossSectionData(orbitalName, 'xy');
                const dataXZ = generate2DCrossSectionData(orbitalName, 'xz');
                const dataYZ = generate2DCrossSectionData(orbitalName, 'yz');
                
                // Store the newly generated data in the cache
                orbitalCache[orbitalName] = {
                    pointCloud3D: pointCloud3D,
                    crossSections2D: {
                        xy: dataXY,
                        xz: dataXZ,
                        yz: dataYZ
                    }
                };

                // Use the new data
                allPositions = pointCloud3D.positions;
                allColors = pointCloud3D.colors;
                applyColorFilter();
                
                drawSlice(ctx2D.xy, dataXY, props.boxSize);
                drawSlice(ctx2D.xz, dataXZ, props.boxSize);
                drawSlice(ctx2D.yz, dataYZ, props.boxSize);

                loader.classList.add('hidden');
            }, 50);
        }

        function onWindowResize() { /* ... (unchanged) ... */ camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight); }
        function animate() { /* ... (unchanged) ... */ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

        init();
    </script>
</body>
</html>